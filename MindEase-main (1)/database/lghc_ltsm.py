# -*- coding: utf-8 -*-
"""LGHC_LTSM.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YMjvviq256xlQCwlWpHijWX-rD1PCLLE
"""

import pandas as pd
import numpy as np
from keras.models import Sequential
from keras.layers import Dense, LSTM


df = pd.read_csv('/content/adult-depression-lghc-indicator-2.csv')
df.info()
df.head()

classes = ['Sex', 'Income', 'Race-Ethnicity', 'Education', 'Age']
# Drop rows with NaN values
df.dropna(inplace=True)

strata_groups = df.groupby('Strata Name')
strata_df = pd.DataFrame()
strata_df['Strata Name'] = strata_groups.first()['Strata Name']
for column in ['Lower Frequency', 'Upper Frequency']:
    strata_df[column] = strata_groups[column].apply(list)

sequence_df = pd.DataFrame()
for column in ['Lower Frequency', 'Upper Frequency']:
    sequence_df[column] = strata_df[column].apply(lambda x: np.array(x))

# Splitting ds into test and train
X_train = sequence_df['Lower Frequency'][:-1]
y_train = sequence_df['Upper Frequency'][:-1]
X_test = sequence_df['Lower Frequency'][-1:]
y_test = sequence_df['Upper Frequency'][-1:]

# normalizing sequence data by max value
X_train_norm = X_train.apply(lambda x: x / np.max(x))
y_train_norm = y_train.apply(lambda x: x / np.max(x))
X_test_norm = X_test.apply(lambda x: x / np.max(x))
y_test_norm = y_test.apply(lambda x: x / np.max(x))

# reshaping data to have 3 dims for ltsm model
X_train_reshaped = np.reshape(X_train_norm.values, (X_train_norm.shape[0], 1, X_train_norm.shape[1]))
y_train_reshaped = np.reshape(y_train_norm.values, (y_train_norm.shape[0], 1, y_train_norm.shape[1]))
X_test_reshaped = np.reshape(X_test_norm.values, (X_test_norm.shape[0], 1, X_test_norm.shape[1]))
y_test_reshaped = np.reshape(y_test_norm.values, (y_test_norm.shape[0], 1, y_test_norm.shape[1]))

# building ltsm model to predict upper frequency 
model = Sequential()
model.add(LSTM(50, activation='relu', input_shape=(1, X_train_norm.shape[1])))
model.add(Dense(y_train_norm.shape[1]))

model.compile(optimizer='adam', loss='mse')
model.fit(X_train_reshaped, y_train_reshaped, epochs=100, verbose=0)

# Evaluate the model on the testing set
score = model.evaluate(X_test_reshaped, y_test_reshaped, verbose=0)
print

# evaluating using Mean squared error b/w predicted and true frequencies

# Predict the upper frequency values for the test set
y_pred = model.predict(X_test_reshaped)

# Scale the predicted upper frequency values back to their original range
y_pred_scaled = y_pred * np.max(y_test_norm)

# Print the predicted upper frequency values
print(y_pred_scaled)